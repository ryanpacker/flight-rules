# 4.4 Orchestration

This task group covers the cross-cutting concerns of how the Ralph Loop is actually executed â€” how fresh AI instances are spawned, how state is persisted across iterations, and how the system handles interruptions.

## Goals

- Define how fresh AI contexts are created for each iteration
- Specify state persistence across instance boundaries
- Handle interruptions, failures, and resumption
- Support both internal (agent-spawning) and external (script) orchestration

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ORCHESTRATION LAYER                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Internal Mode    â”‚          â”‚ External Mode    â”‚             â”‚
â”‚  â”‚ (Agent Spawning) â”‚          â”‚ (CLI Wrapper)    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚           â”‚                             â”‚                        â”‚
â”‚           â”‚   Uses Task tool to         â”‚   Shell script         â”‚
â”‚           â”‚   spawn sub-agents          â”‚   invokes claude-code  â”‚
â”‚           â”‚                             â”‚                        â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                         â”‚                                        â”‚
â”‚                         â–¼                                        â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚           â”‚     State Persistence       â”‚                        â”‚
â”‚           â”‚  .continuous-session-state  â”‚                        â”‚
â”‚           â”‚  .task-loop-state           â”‚                        â”‚
â”‚           â”‚  prd-status.json            â”‚                        â”‚
â”‚           â”‚  progress.md                â”‚                        â”‚
â”‚           â”‚  session_logs/              â”‚                        â”‚
â”‚           â”‚  git commits                â”‚                        â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                         â”‚                                        â”‚
â”‚                         â–¼                                        â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚           â”‚   Resumption Protocol       â”‚                        â”‚
â”‚           â”‚  - Read state files         â”‚                        â”‚
â”‚           â”‚  - Determine position       â”‚                        â”‚
â”‚           â”‚  - Continue iteration       â”‚                        â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dependencies

- Session Continuation Mode (4.1)
- Task Verification Layer (4.2)
- Story Tracking (4.3)

---

## 4.4.1. Internal Orchestration (Agent Spawning)

**Goal**: Enable the loop to run within Claude Code by spawning sub-agents.

**Approach**:

Use Claude Code's Task tool to spawn fresh agent instances:

```markdown
## Orchestration via Task Tool

When the continuous-session command completes one iteration:

1. Update state files (commit progress)
2. Spawn a new agent via Task tool:
   - `subagent_type: "general-purpose"`
   - Fresh context (no conversation history)
   - Prompt includes: "Continue the continuous session loop"
3. New agent reads state files to understand position
4. New agent executes next iteration
5. Repeat until termination condition
```

**Spawning Prompt Template**:
```
You are continuing an autonomous continuous session loop.

1. Read docs/.continuous-session-state.json for current state
2. Read the most recent session log in docs/session_logs/
3. Execute the next item in the queue
4. Update state and session logs
5. If more items remain and under limit, spawn next iteration

Current state file: docs/.continuous-session-state.json
```

**Advantages**:
- Native to Claude Code
- No external tooling required
- Agent has full tool access

**Disadvantages**:
- Cost accumulates (parent agent stays active)
- Depth limits may apply
- Less true "fresh context" than external

**Deliverables**:
- Spawning prompt template
- Agent coordination protocol

**Acceptance Criteria**:
- Agents can spawn and continue loops
- State is correctly read/written across spawns
- Termination conditions work correctly

**Status**: ðŸ”µ Planned

---

## 4.4.2. External Orchestration (CLI Wrapper)

**Goal**: Enable the loop to run via an external script that invokes Claude Code.

**Approach**:

**Shell Script: `ralph-loop.sh`**
```bash
#!/bin/bash
# Ralph Loop Orchestrator for Flight Rules

MAX_ITERATIONS=${1:-5}
PAUSE_ON_FAIL=${2:-false}
ITERATION=0

# Initialize state
echo '{"status":"running","currentIteration":0}' > docs/.ralph-loop-state.json

while [ $ITERATION -lt $MAX_ITERATIONS ]; do
    ITERATION=$((ITERATION + 1))
    echo "=== Starting iteration $ITERATION of $MAX_ITERATIONS ==="

    # Update iteration in state
    jq ".currentIteration = $ITERATION" docs/.ralph-loop-state.json > tmp && mv tmp docs/.ralph-loop-state.json

    # Invoke Claude Code with the continuation prompt
    claude-code --print "$(cat <<'EOF'
You are running iteration {ITERATION} of a Ralph Loop.

1. Read docs/.continuous-session-state.json
2. Find the next actionable item in the queue
3. If no items remain, output "LOOP_COMPLETE" and exit
4. Execute a single session for that item
5. Run verification if specified
6. Update state files and commit
7. Output "ITERATION_COMPLETE" or "ITERATION_FAILED"
EOF
)"

    # Check result
    RESULT=$?
    if [ $RESULT -ne 0 ] && [ "$PAUSE_ON_FAIL" = true ]; then
        echo "Iteration failed. Pausing for review."
        read -p "Press enter to continue or Ctrl+C to abort..."
    fi

    # Check for completion signal
    if grep -q "LOOP_COMPLETE" /tmp/claude-output; then
        echo "Loop completed successfully!"
        break
    fi

    # Small delay between iterations
    sleep 2
done

# Generate summary
claude-code --print "Generate a summary of the Ralph Loop run from docs/.continuous-session-state.json"
```

**Advantages**:
- True fresh context each iteration
- No token accumulation
- Can run overnight/unattended
- Fully scriptable (cron, CI, etc.)

**Disadvantages**:
- Requires external script setup
- Claude Code CLI must be available
- Context loading overhead each iteration

**Deliverables**:
- Shell script template
- Integration guide for various environments

**Acceptance Criteria**:
- Script correctly invokes Claude Code
- State persists across invocations
- Completion detection works
- Failure handling is robust

**Status**: ðŸ”µ Planned

---

## 4.4.3. State Persistence Protocol

**Goal**: Define how all state is persisted to survive instance boundaries.

**Approach**:

**State Files**:

| File | Purpose | Updated When |
|------|---------|--------------|
| `docs/.continuous-session-state.json` | Session loop progress | Each session start/end |
| `docs/.task-loop-state.json` | Task loop progress | Each task completion |
| `docs/prd-status.json` | Story completion | Story verification |
| `docs/progress.md` | Human-readable log | Each session end |
| `docs/session_logs/*.md` | Detailed session docs | Each session end |
| Git commits | Code changes | Each successful verification |

**State File Schemas** (consolidated):

```typescript
// .continuous-session-state.json
interface ContinuousSessionState {
  status: 'running' | 'paused' | 'stopping' | 'complete' | 'failed';
  startedAt: string;  // ISO timestamp
  lastUpdated: string;
  maxSessions: number;
  currentSession: number;
  sourceSession: string;  // Path to starting session log
  completedItems: Array<{
    title: string;
    sessionLog: string;
    verification: 'passed' | 'failed' | 'skipped';
    duration: number;  // ms
  }>;
  failedItems: Array<{
    title: string;
    error: string;
    sessionLog: string;
  }>;
  queueSnapshot: string[];  // Items remaining when state was saved
}

// .task-loop-state.json
interface TaskLoopState {
  status: 'running' | 'paused' | 'stopping' | 'complete' | 'failed';
  startedAt: string;
  lastUpdated: string;
  maxIterations: number;
  currentIteration: number;
  currentTask: string;  // Task ID
  scope: {
    area?: string;
    taskGroup?: string;
  };
  completedTasks: Array<{
    id: string;
    title: string;
    verified: boolean;
    duration: number;
  }>;
  failedTasks: Array<{
    id: string;
    title: string;
    error: string;
    attempts: number;
  }>;
}
```

**Persistence Rules**:

1. **Write state before starting work** â€” If interrupted mid-task, state shows "in progress"
2. **Write state after completing work** â€” Reflects actual progress
3. **Commit after verification passes** â€” Code changes are durable
4. **Session logs are source of truth** â€” State files can be regenerated from logs

**Recovery**:
- If state shows "running" but no agent is active â†’ resume from last completed
- If state is corrupted â†’ rebuild from session logs and git history

**Deliverables**:
- State file schemas
- Persistence timing rules
- Recovery procedures

**Acceptance Criteria**:
- State survives process termination
- State can be manually inspected
- Recovery works for common failure modes

**Status**: ðŸ”µ Planned

---

## 4.4.4. Resumption Protocol

**Goal**: Enable interrupted loops to resume correctly.

**Approach**:

**Resumption Command**: `/continuous-session.resume` or automatic via `/continuous-session.start`

**Resumption Flow**:

1. **Check for existing state**
   ```
   if exists(docs/.continuous-session-state.json):
       state = read(state_file)
       if state.status == 'running':
           prompt: "Found in-progress loop (session {N}/{M}). Resume? [Y/n]"
       elif state.status == 'paused':
           prompt: "Found paused loop. Resume from session {N}? [Y/n]"
       elif state.status == 'stopping':
           prompt: "Loop was stopping. Mark complete and show summary? [Y/n]"
   ```

2. **Determine resumption point**
   - If current session was complete â†’ move to next
   - If current session was in progress â†’ check git status:
     - Uncommitted changes â†’ offer to continue or discard
     - Clean state â†’ retry the session

3. **Rebuild queue if needed**
   - Read most recent session log's "Next Steps"
   - Filter out items in `completedItems`
   - Resume with remaining queue

4. **Continue iteration**
   - Update state: `lastUpdated`, `status: running`
   - Execute next session
   - Normal loop flow

**Edge Cases**:

| Situation | Resolution |
|-----------|------------|
| State says "running" but no process | Resume from last completed |
| Uncommitted changes present | Ask user: commit, discard, or continue |
| Queue is empty but state says "running" | Mark complete |
| Session log missing | Regenerate from git commits |
| Verification timed out mid-run | Retry the verification |

**Deliverables**:
- Resumption command specification
- Edge case handling logic

**Acceptance Criteria**:
- Loops can be interrupted and resumed
- No work is lost on interruption
- Edge cases are handled gracefully

**Status**: ðŸ”µ Planned

---

## 4.4.5. Failure Recovery

**Goal**: Define comprehensive failure recovery strategies.

**Approach**:

**Failure Types and Responses**:

| Failure Type | Detection | Response |
|--------------|-----------|----------|
| Verification failure | Non-zero exit code | Retry, create fix task, or pause |
| Implementation failure | Agent reports inability | Log, skip, or pause for human |
| Timeout | Exceeded time limit | Kill process, mark failed, continue |
| Network error | API failure | Retry with backoff |
| Git conflict | Merge conflict on commit | Pause for human resolution |
| State corruption | JSON parse error | Rebuild from session logs |
| Resource exhaustion | Out of tokens/memory | Pause, alert, resume later |

**Retry Logic**:
```typescript
interface RetryConfig {
  maxAttempts: number;     // Default: 2
  backoffMs: number[];     // Default: [1000, 5000, 15000]
  retryableErrors: string[]; // Patterns that trigger retry
}

async function executeWithRetry(
  action: () => Promise<Result>,
  config: RetryConfig
): Promise<Result> {
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await action();
    } catch (error) {
      if (attempt < config.maxAttempts && isRetryable(error, config)) {
        await sleep(config.backoffMs[attempt - 1]);
        continue;
      }
      throw error;
    }
  }
}
```

**Failure Log Format**:
```markdown
## Failure Log

### Iteration 3 - 2025-01-17T15:30:00Z

**Task:** Add error handling to API routes
**Verification:** npm run build
**Result:** FAILED

**Error Output:**
```
src/api/routes.ts(42,5): error TS2345: Argument of type 'string' is not
assignable to parameter of type 'number'.
```

**Action Taken:** Created fix task 3.2.1a
**State:** Continuing to next item
```

**Deliverables**:
- Failure type catalog
- Retry configuration
- Failure log format

**Acceptance Criteria**:
- All failure types have defined responses
- Retries use exponential backoff
- Failures are logged with actionable info

**Status**: ðŸ”µ Planned

---

## 4.4.6. Termination Conditions

**Goal**: Define when and how the loop should stop.

**Approach**:

**Normal Termination**:

1. **Queue exhausted**
   - All items in "Next Steps" processed
   - No more unverified tasks (for task-loop)
   - All stories pass (for story-loop)

2. **Limit reached**
   - `maxSessions`, `maxIterations`, or `maxStories` hit
   - Loop stops gracefully, preserves remaining queue

3. **User stop**
   - `/continuous-session.stop` command
   - Complete current work, then exit

**Abnormal Termination**:

4. **Fatal error**
   - Unrecoverable failure (e.g., git corruption)
   - State set to 'failed', detailed error logged

5. **Repeated failures**
   - Same item fails N times consecutively
   - Optionally auto-pause or mark blocked

6. **External signal**
   - SIGINT, SIGTERM
   - Save state, exit cleanly

**Termination Summary**:

After any termination, generate summary showing:
- How the loop ended (completed, limit, stopped, failed)
- Items completed successfully
- Items that failed
- Items remaining
- Total duration
- Next steps for human

**Deliverables**:
- Termination condition specifications
- Signal handling for external mode
- Summary generation for all termination types

**Acceptance Criteria**:
- All termination paths generate useful summaries
- State is always saved on termination
- Graceful handling of signals

**Status**: ðŸ”µ Planned

---

## 4.4.7. Monitoring and Observability

**Goal**: Provide visibility into running loops.

**Approach**:

**Status Commands**:
- `/continuous-session.status` â€” Current session loop state
- `/task-loop.status` â€” Current task loop state
- `/story-loop.status` â€” Current story completion state

**Log Output** (for external monitoring):
```
[2025-01-17T14:00:00Z] ralph-loop: Starting iteration 1/5
[2025-01-17T14:00:01Z] ralph-loop: Selected item: "Implement user auth"
[2025-01-17T14:03:22Z] ralph-loop: Implementation complete
[2025-01-17T14:03:23Z] ralph-loop: Running verification: npm test
[2025-01-17T14:03:45Z] ralph-loop: Verification PASSED (exit 0)
[2025-01-17T14:03:46Z] ralph-loop: Committing changes
[2025-01-17T14:03:48Z] ralph-loop: Iteration 1 complete (3m 48s)
[2025-01-17T14:03:50Z] ralph-loop: Starting iteration 2/5
```

**Webhook/Notification Support** (future):
- Slack notification on completion/failure
- Email summary
- CI status update

**Metrics Collection** (future):
- Time per iteration
- Pass/fail rates
- Token usage per session

**Deliverables**:
- Log format specification
- Status command integration
- (Future) Notification hooks

**Acceptance Criteria**:
- Running loops can be monitored
- Logs are parseable and informative
- Status commands work for all loop types

**Status**: ðŸ”µ Planned

---

## 4.4.8. Security Considerations

**Goal**: Ensure the Ralph Loop operates safely.

**Approach**:

**Risks and Mitigations**:

| Risk | Mitigation |
|------|------------|
| Runaway loop consuming resources | Hard limits on iterations, timeouts |
| Verification command injection | Only run commands from trusted spec files |
| Unintended git operations | Never force push, require explicit confirmation for destructive ops |
| Sensitive data in logs | Don't log full stdout/stderr, redact known patterns |
| Infinite retry loops | Max retry limit, exponential backoff |
| Unauthorized file modifications | Sandbox verification commands where possible |

**Command Allowlist**:
- Verification commands should be limited to known-safe patterns
- Consider: `npm test`, `npm run build`, `cargo test`, `pytest`, etc.
- Warn or block on suspicious commands (e.g., `rm -rf`, `curl | sh`)

**Audit Trail**:
- All loop actions logged with timestamps
- Git commits provide code change audit
- Session logs provide decision audit

**Deliverables**:
- Security risk assessment
- Command validation rules
- Audit logging requirements

**Acceptance Criteria**:
- Known risks have mitigations
- Verification commands are validated
- Full audit trail is maintained

**Status**: ðŸ”µ Planned
